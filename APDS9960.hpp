/*
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

/**
 * @file APDS9960.hpp
 * @author Tim van Mourik (tim.vanmourik1@student.hu.nl)
 * @brief Header file for the APDS9960 library. 
 */

#ifndef IPASS_APDS9960_HPP
#define IPASS_APDS9960_HPP

#define APDS9960_I2C_ADDR           0x39
#define APDS9960_ID                 0x92
#define EXPECTED_ID_1               0xAB
#define EXPECTED_ID_2               0xA8

#define APDS9960_PDATA              0x9C
#define APDS9960_CONTROL            0x8F
#define APDS9960_PILT               0x89
#define APDS9960_PIHT               0x8B
#define APDS9960_PPULSE             0x8E
#define APDS9960_CDATAL             0x94
#define APDS9960_CDATAH             0x95
#define APDS9960_RDATAL             0x96
#define APDS9960_RDATAH             0x97
#define APDS9960_GDATAL             0x98
#define APDS9960_GDATAH             0x99
#define APDS9960_BDATAL             0x9A
#define APDS9960_BDATAH             0x9B
#define APDS9960_ATIME              0x81
#define APDS9960_CONTROL_AGAIN_1X   0x00
#define APDS9960_CONTROL_AGAIN_4X   0x01
#define APDS9960_CONTROL_AGAIN_16X  0x02
#define APDS9960_CONTROL_AGAIN_64X  0x03

//enable register
#define APDS9960_REG_ENABLE             0x80
#define APDS9960_ENABLE_PON             0x01    // Power ON
#define APDS9960_ENABLE_AEN             0x02    // ALS enable
#define APDS9960_ENABLE_PEN             0x04    // Proximity Detech enable
#define APDS9960_ENABLE_WEN             0x08    // Wait enable
#define APDS9960_ENABLE_AIEN            0x10    // ALS Interrupt enable
#define APDS9960_ENABLE_GEN             0x40    // Gesture enable 


#define APDS9960_AICLEAR                0xE7 // AI (Ambient Light) clear channel interrupt threshold clear
#define APDS9960_GCONFIG3               0xA3 // Gesture configuration 3
#define APDS9960_GCONFIG1               0xA5 // Gesture configuration 1
#define APDS9960_GCONFIG2               0xA7 // Gesture configuration 2
#define APDS9960_GCONFIG4               0xAB
#define APDS9960_GPENTH                 0xA9 // Gesture proximity enter threshold
#define APDS9960_GEXTH                  0xAB // Gesture exit threshold
#define APDS9960_GPULSE                 0x8E // Gesture pulse count
#define APDS9960_GFLVL                  0xAE // Gesture FIFO level
#define APDS9960_GSTATUS                0xAF // Gesture status
#define APDS9960_GFIFO_U                0xFC // Gesture FIFO UP value
#define APDS9960_GFIFO_D                0xFD // Gesture FIFO DOWN value
#define APDS9960_GFIFO_L                0xFE // Gesture FIFO LEFT value
#define APDS9960_GFIFO_R                0xFF // Gesture FIFO RIGHT value
#define APDS9960_WTIME                  0x83

#define LED_BOOST_300                   0x03    // LED Boost value for 300%
#define DEFAULT_GESTURE_PPULSE          0x89    // Default gesture pulse length
#define APDS9960_FIFO_PAUSE_TIME        30  
#define APDS9960_GVALID                 0b00000001
#define APDS9960_GESTURE_THRESHOLD_OUT  10
#define APDS9960_GESTURE_SENSITIVITY_1  50
#define APDS9960_GESTURE_SENSITIVITY_2  20


#define APDS9960_UP                     0x01    /**< Gesture Up */
#define APDS9960_DOWN                   0x02    /**< Gesture Down */
#define APDS9960_LEFT                   0x03    /**< Gesture Left */
#define APDS9960_RIGHT                  0x04    /**< Gesture Right */

#include "hwlib.hpp"

/**
 * @class APDS9960
 * @brief A class to interface the APDS9960. 
 * 
 * This class allows for interaction between user and the color-, proximity- and gesture sensors.
 */

class APDS9960 {
public:
    /**
     * @brief Constructor for APDS9960 class.
     * 
     * @param i2c_bus The I2C to communicate with the sensor
     */
    APDS9960(hwlib::i2c_bus &i2c_bus);

    /**
     * @brief Initialize the APDS9960 sensor.
     *  
     * @return true if initialization was succesful
     * @return false if the initialization failed
     */
    bool init();



    // PROXIMITY

    /**
     * @brief Enable or disable the proximity sensor.
     * 
     * @param enable true to enable | false to disable.
     */
    void enableProximity(bool enable);

    /**
     * @brief Read proximity value.
     * 
     * @return int The proximity value.
     */
    int readProximity();



    // COLOR

    /**
     * @brief Enable or disable the color sensor.
     * 
     * @param enable true to enable | false to disable.
     */
    void enableColor(bool enable);

    /**
     * @brief Check if color is available.
     * 
     * @return true color data is available.
     * @return false color data is NOT available.
     */
    bool isColorAvailable();

    /**
     * @brief Get the color data.
     * 
     * @param red Reference to integer where red part is stored
     * @param green Reference to integer where green part is stored
     * @param blue Reference to integer where blue part is stored
     * @param clear Reference to integer where clear part is stored
     */
    void getColorData(uint16_t &red, uint16_t &green, uint16_t &blue, uint16_t &clear);



    // GESTURE

    /**
     * @brief Enable or disable the gesture sensor.
     * 
     * @param enable true to enable | false to disable.
     */
    void enableGesture(bool enable);

    /**
     * @brief Check if a gesture is available.
     * 
     * @return true Gesture is available
     * @return false Gesture is NOT available
     */
    bool isGestureAvailable();
    
    /**
     * @brief Read detected gesture.
     * 
     * @return uint8_t Read gesture value.
     */
    uint8_t readGesture();

    /**
     * @brief Process the gesture data.
     * 
     * @param buffer Buffer to store gesture data.
     * @param n_bytes_to_read Number of bytes to read.
     * @param z_axis_diff Reference to store the difference on z-axis. Could also be interpeted as forward/backward or up/down.
     * @param x_axis_diff Reference to store the difference on x-axis. Could also be interpreted as left/right.
     * @return true If the data processing was successful.
     * @return false If the data processing was NOT successful.
     */
    bool processGestureData(uint8_t* buffer, uint8_t n_bytes_to_read, int& z_axis_diff, int& x_axis_diff);

    /**
     * @brief Calculate the direction of the gesture based on the axis differences.
     * 
     * @param z_axis_diff The difference on z-axis. Could also be interpeted as forward/backward or up/down.
     * @param x_axis_diff The difference on x-axis. Could also be interpreted as left/right.
     * @return uint8_t The gesture direction.
     */
    uint8_t calculateGestureDirection(int z_axis_diff, int x_axis_diff);

    /**
     * @brief Get the current gesture.
     * 
     * @return uint8_t The current value of the gesture.
     */
    uint8_t getGesture();

    /**
     * @brief Reset gesture counts.
     * 
     */
    void resetCounts();


private:

    /**
     * @brief Write a value to a register.
     * 
     * @param reg The address of the register.
     * @param value The value to write.
     */
    void writeReg(uint8_t reg, uint8_t value);
    
    /**
     * @brief Read a value from a register.
     * 
     * @param reg The adress of the register.
     * @return uint8_t The value that was read from the register.
     */
    uint8_t readReg(uint8_t reg);

    /**
     * @brief Read a block of values from a register.
     * 
     * @param reg The adress of the register.
     * @param buffer Buffer to store the read values.
     * @param length Number of bytes to read.
     * @return uint16_t The number of bytes that have been read.
     */
    uint16_t readRegBlock(uint8_t reg, uint8_t* buffer, uint8_t length);

    
    hwlib::i2c_bus &i2c_bus; /**< The I2C bus object for communication. */

    uint8_t gesture_count; /**< Counter for gestures. */
    uint8_t up_count; /**< Counter of up gestures. */
    uint8_t down_count; /**< Counter for down gestures. */
    uint8_t left_count; /**< Counter for left gestures. */
    uint8_t right_count; /**< Counter for right gestures. */
};
    

#endif // IPASS_APDS9960_HPP
